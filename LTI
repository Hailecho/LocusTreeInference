#! /usr/bin/python
from src.lineage_separation import decompose
import getopt
import sys
import ete2

help_text = """
NAME
    LTI: Locus Tree Inference
USAGE
    LTI [OPTIONS] 
DESCRIPTION
    Decomposes the evolutionary history of loci in the gene tree, based on
    the supplied species tree.
    If the species tree's internal nodes are named, then those names are used.
    Otherwise, new names are created by concatenating names of leafs.
    Species tree needs to contain only the names of nodes (no supports, branches etc.)
    By default, this requirements holds also for gene trees. If you wish to
    preserve branch lenghts and/or supports in the results, please
    indicate the input gene tree format (as specified by ete3 documentation). 
OPTIONS
    -g: Gene tree
    -s: Species tree
        Either paths to files with the trees in Newick format, or the trees itself as strings.
        The tree in Newick format needs to end with a semicolon.
        NHX annotations are allowed, but will not be preserved in the output. 
    -f: Return forest
        Returns the forest obtained after decomposition.
        Otherwise, returns a gene tree with NHX attributes containing indicator if a node
        is the first observation of a new loci (NHX new_locus), the embedding
        of the node into the species tree given by the species tree's node name (NHX embedding),
        and the post-hoc transfer score (NHX score).
    -r: Return roots
        Returns the roots file. This is a file with three lines. The first one contains the gene tree,
        the second one the species tree, and the third one the list of postorder IDs of root nodes 
        from the decomposition forest.
    -e: Gene tree format
        Newick format of the input gene tree (as in ete2). Default: 9, leaf names only.
        The format will be preserved in the locus tree output, but not in the forest or roots output. 
    -n: Suppress automatic ranking
        If this flag is not set, the species tree will be ranked automatically based on the nodes' topology.
        Alternatively, one may specify the ranks as NHX attributes. Example: 
        '(S3[&&NHX:rank=0],(S2[&&NHX:rank=0],S1[&&NHX:rank=0])[&&NHX:rank=1]);'
    
"""


if __name__ == "__main__":
    return_format = "tree"
    species_tree = None
    gene_tree = None
    gene_format = 9
    automatic_ranking = True
    if len(sys.argv) <= 1:
        print help_text
        quit()
    opts, args = getopt.getopt(sys.argv[1:], "g:s:e:fhrn")
    for opt, arg in opts:
        if opt == '-g':
            gene_tree = arg
        elif opt == '-s':
            species_tree = arg
        elif opt == '-f':
            return_format = "forest"
        elif opt == '-r':
            return_format = "roots"
        elif opt == '-h':
            print help_text
            quit()
        elif opt == '-e':
            gene_format = int(arg)
        elif opt == '-n':
            automatic_ranking = False

    # if gene_tree[-1] != ';':
    #     gene_tree += ';'
    # if species_tree[-1] != ';':
    #     species_tree += ';'

    species_tree = ete2.Tree(species_tree, format=8)
    gene_tree = ete2.Tree(gene_tree, format=gene_format)

    if automatic_ranking:
        from src.lineage_separation import assign_ranks
        assign_ranks(species_tree)

    D = decompose(gene_tree, species_tree)

    if return_format == "forest":
        forest = D.forest()
        print ' '.join(f.write(format=9) for f in forest)
    elif return_format == "tree":
        locus_tree = D.locus_tree()
        D._assert_sources()
        print locus_tree.write(format=gene_format, features=["source", "locus_id", "I", "P"], format_root_node=True)
    elif return_format == "roots":
        for g in gene_tree:
            g.name = g.name.split('_')[0]
        to_write = gene_tree.write(format=9).replace(';', '') + '\n'
        to_write += species_tree.write(format=9).replace(';', '') + '\n'
        to_write += '(' + ','.join(map(str, D.roots)) + ')'
        print to_write

